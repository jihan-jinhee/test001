## 도시를 세운다면

* 도시의 세세한 사항을 혼자서 직접 관리할 수 있을까?
* 도시가 잘 돌아가는 이유는 `수도 관리 팀`, `전력 관리 팀`, `교통 관리 팀`, `치안 관리 팀` 등 각 분야를 관리하는 팀이 있기 때문
* 이는 `추상화`, `모듈화`가 잘 되어 있는 구조.
* SW팀도 도시처럼 구성하지만, 추상화를 이뤄내지 못한다.
   * 깨끗한 코드는 높은 추상화 수준(=시스템 수준)에서도 깨끗함을 유지하게 해준다.
 
## 시스템 제작과 시스템 사용을 분리하라

* 호텔을 짓는 것과, 호텔을 사용하는 것은 아주 다르다.
* 소프트웨어 시스템은 준비과정과 <-> 런타임 로직을 분리해야 한다.
* `객체 생성` & `의존성 연결` <-> `런타임 로직`

```java
// Lazy Initialization/Evaluation(게으른 초기화)
public Service getService(){
  if (service == null)
    service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
  return service;
}
```
장점
* 필요할때 까지 객체생성을 미루므로 불필요한 부하가 걸리지 않는다.
* null 포인트를 반환하지 않는다.

단점
* MyServiceImpl 생성자 인수에 명시적으로 의존한다.
* 만약 MyServiceImpl이 무거운 객체라면 테스트를 위한 적절한 테스트 전용 객체(Test Double / Mock Object)를 할당해야한다.
* 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행경로를 테스트 해야 한다.
   * 책임이 2개이기에, 단일 책임 원칙을 위반한다.
 
* 체계적이고 탄탄한 시스템을 위해서는 모듈성을 깨서는 안 된다.
* 설정 논리는 일반 실행 논리와 분리해야 한다.

## Main 분리
![image](https://github.com/jihan-jinhee/test001/assets/74603608/cb152515-176a-4ab5-a963-e83c2321b0c4)

* 시스템 생성과, 시스템 사용을 분리하는 방법
* Main에서는 생성, 나머지 시스템은 객체 생성, 의존성 연결

Main의 역할
* 시스템에 필요한 객체를 생성

애플리케이션의 역할
* 그저 객체를 사용

## 팩토리
* 객체가 생성되는 시점을 애플리케이션이 결정할 필요가 생긴다.
![image](https://github.com/jihan-jinhee/test001/assets/74603608/761661c7-9314-4f4c-be76-a7b720042801)

* 주문 처리 시스템에서 어플리케이션은 LineItem 인스턴스를 생성해 Order에 넘긴다. 그러면 LineItem을 생성하는 시점은 어플리케이션이 결정하지만 LineItem을 생성하는 코드는 어플리케이션이 모른다.
* OrderProcessing 어플리케이션은 LineItem이 생성되는 구체적인 방법은 모른다.
* 그럼에도, LineItem 인스턴스가 생성되는 시점을 완벽하게 통제하며, 필요하다면 OrderProcessing 애플리케이션에서만 사용하는 생성자 인수도 넘길 수 있다.

<details>
<summary>팩토리 패턴 종류</summary>

## 심플 팩토리 패턴
* 객체를 생성하는 클래스를 따로 두는 것
```java
//휴대폰을 만드는 공장
public class SimplePhoneFactory {
    public Phone orderPhone(String type) {
        Phone phone = createPhone(type);
        phone.complete();
        return phone;
    }
    private Phone createPhone(String type) {
        return switch (type) {
            case "IPHONE" -> new IPhone();
            case "ANDROID" -> new AndroidPhone();
            default -> null;
        };
    }
}

//휴대폰 인터페이스
public interface Phone {
    void complete();
    void call();
}

//아이폰
public class IPhone implements Phone{
    @Override
    public void complete() {
        System.out.println("아이폰 완성");
    }

    @Override
    public void call() {
        System.out.println("아이폰으로 전화를 한다");
    }
}

//안드로이드 폰
public class AndroidPhone implements Phone{
    @Override
    public void complete() {
        System.out.println("안드로이드폰 완성");
    }

    @Override
    public void call() {
        System.out.println("안드로이드폰으로 전화를 한다");
    }
}

//클라이언트는 휴대폰 공장에 휴대폰을 주문한다.
public class Practice {
    public static void main(String[] args){
        SimplePhoneFactory simplePhoneFactory = new SimplePhoneFactory();
        Phone phone = simplePhoneFactory.orderPhone("ANDROID");
        phone.call();
    }
}
```
![image](https://github.com/jihan-jinhee/test001/assets/74603608/c95d87f5-9bbb-4916-bba5-8cd06f95db1e)

* 객체를 만드는 작업을 하나의 팩토리 클래스에 모아두었다.

## 팩토리 메서드 패턴
* 클래스의 인스턴스를 만드는 일을 서브클래스에 맡기는 것
```java
public interface PhoneFactory {
    default Phone orderPhone() {
        Phone phone = createPhone();
        phone.complete();
        return phone;
    }
    Phone createPhone();
}

public class IPhoneFactory implements PhoneFactory {
    @Override
    public Phone createPhone() {
        return new IPhone();
    }
}

public class AndroidPhoneFactory implements PhoneFactory {
    @Override
    public Phone createPhone() {
        return new AndroidPhone();
    }
}

public interface Phone {
    void complete();
    void call();
}
public class IPhone implements Phone{
    @Override
    public void complete() { System.out.println("아이폰 완성"); }
    @Override
    public void call() { System.out.println("아이폰으로 전화를 한다"); }
}
public class AndroidPhone implements Phone{
    @Override
    public void complete() {System.out.println("안드로이드폰 완성");}
    @Override
    public void call() {System.out.println("안드로이드폰으로 전화를 한다");}
}

public class Practice {
    public static void main(String[] args){
        IPhoneFactory iPhoneFactory = new IPhoneFactory();
        Phone phone7 = iPhoneFactory.orderPhone();
        phone7.call();

        AndroidPhoneFactory androidPhoneFactory = new AndroidPhoneFactory();
        Phone phone2 = androidPhoneFactory.orderPhone();
        phone2.call();
    }
}

```
![image](https://github.com/jihan-jinhee/test001/assets/74603608/df9de940-87ea-401f-adfc-f2021d79c36f)

* SimplePhoneFactory를 인터페이스화 하여, 구현체로 IPhoneFactory, AndroidPhoneFactory를 만들고 `createPhone()`을 각자의 Factory에서 Phone 객체 생성 구현체를 만든다.
* 서브클래스(IPhoneFactory,AndroidPhoneFactory)에서 어떤 객체를 생성할지 결정할 수 있다.
* 확장은 가능하게 하면서, 추후에 수정할 필요는 없는 `OCP` (개방 폐쇄의 원칙 : Open Close Principle)를 따르게 된다.

## 추상 팩토리 패턴
* 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
* 메소드 팩토리 패턴은 PhoneFactory의 구현체 IPhoneFactory, AndroidPhoneFactory가 각각 IPhone객체 AndroidPhone객체 하나씩을 생성하게끔 작성했다.
* 추상 팩토리 패턴은 이것을 한번더 감싸서 하나의 Factory에서 여러개의 제품군(Product)조합을 생성할 수 있게 해주는 패턴이다.

```java
public class Main {
    public static void main(String[] args) {
        PhoneFactoryOfFactory phoneFactoryOfFactory = new DefaultPhoneFactoryOfFactory();
        PhoneFactory iphoneFactory= phoneFactoryOfFactory.requestPhone("IPHONE");   //아이폰을 산다.
        Phone iphone = iphoneFactory.createPhone();
        iphone.call();
        iphone.playGame();

        PhoneFactory androidPhoneFactory = phoneFactoryOfFactory.requestPhone("ANDROID");   //안드로이드폰을 산다.
        Phone androidPhone = androidPhoneFactory.createPhone();
        androidPhone.call();
        androidPhone.playGame();
    }
}
```

![image](https://github.com/jihan-jinhee/test001/assets/74603608/8efc4489-af1a-44a9-a830-7942e81306b6)

* IPhoneFactory는 IPhone과 IOS조합으로 객체를 생성
* AndroidPhoneFactory는 AndroidPhone과 GoogleOS조합으로 객체를 생성

장점
* 구체적인 클래스를 사용자로부터 분리할 수 있다.
   → 사용자가 사용할 때는 정의된 인터페이스에 정의된 추상 메소드를 사용만 하면 된다.
* 제품군을 쉽게 대체할 수 있다.
   → 내가 만약 IPhone대신 블랙베리 폰을 생성하고 싶다면 BlackBerry를 구현후 IPhoneFactory를 BlackBerryFactory로 변경만 해주면 된다.

단점
* 새로운 종류의 제품을 제공하기 어렵다
   → 만약 PhoneFactory에 createBattery()라는 추상 메소드가 추가된다면 PhoneFactory의 모든 서브 구현체를 다시 수정해야한다.
</details>

## 의존성 주입 (Dependency Injection)
* 사용과 제작을 분리하는 강력한 메커니즘
* `의존성 관리`에 `제어 역전 기법`을 적용한 메커니즘

* 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.
* 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지킨다. (Single Responsibility Principle)
* 의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임이 없다. 대신, 이를 다른 '전담' 메커니즘에 넘겨야 한다. (이 과정이 제어 역전)
* 초기 설정은 시스템 전체에서 필요하므로 대개 '책임질' 메커니즘으로 'main' 루틴이나 특수 컨테이너를 사용

```java
// JNDI 검색 의존성 주입을 "부분적으로 구현"
MyService myService = (MyService)(jndiContext.lookup("NameOfMyService"));
```
* 객체는 디렉터리 서버에 이름을 제공하고 그 이름에 일치하는 서비스를 요청한다.
* 호출하는 객체는 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 의존성을 능동적으로 해결한다.


* 진정한 의존성 주입은 한 단계 더 나아가 완전히 수동적인 형태를 지닌다.
   * 의존성을 필요로 하는 객체가 직접 의존성을 해결(생성, 연결)하는 대신
   * 생성자/setter 등을 통해 DI 컨테이너가 해당 의존성을 해결하도록 도와준다
* 계산 지연기법이나 유사한 최적화 기법에서 사용.
   * 필요할때까지는 객체를 생성하지 않는다.
   * 팩토리를 호출하거나 프록시를 생성한다.
